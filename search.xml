<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(转载) S.O.L.I.D PHP 面向对象设计的五个基准原则]]></title>
    <url>%2Fp%2F004a.html</url>
    <content type="text"><![CDATA[S.O.L.I.D 意思是：扩展出来的首字母缩略词看起来可能很复杂，实际上它们很容易理解。 S - 单一功能原则 O - 开闭原则 L - 里氏替换原则 I - 接口隔离原则 D - 依赖反转原则 接下来让我们看看每个原则，来了解为什么 S.O.L.I.D 可以帮助我们成为更好的开发人员。 单一职责原则缩写是 S.R.P ，该原则内容是: 一个类有且只能有一个因素使其改变，意思是一个类只应该有单一职责． 例如，假设我们有一些图形，并且想要计算这些图形的总面积．是的，这很简单对不对？ 123456789101112131415class Circle &#123; public $radius; public function __construct($radius) &#123; $this-&gt;radius = $radius; &#125;&#125;class Square &#123; public $length; public function __construct($length) &#123; $this-&gt;length = $length; &#125;&#125; 首先，我们创建图形类，该类的构造方法初始化必要的参数．接下来，创建AreaCalculator 类，然后编写计算指定图形总面积的逻辑代码． 123456789101112131415161718192021class AreaCalculator &#123; protected $shapes; public function __construct($shapes = array()) &#123; $this-&gt;shapes = $shapes; &#125; public function sum() &#123; // logic to sum the areas &#125; public function output() &#123; return implode('', array( "", "Sum of the areas of provided shapes: ", $this-&gt;sum(), "" )); &#125;&#125; AreaCalculator 使用方法，我们只需简单的实例化这个类，并且传递一个图形数组，在页面底部展示输出内容． 123456789$shapes = array( new Circle(2), new Square(5), new Square(6));$areas = new AreaCalculator($shapes);echo $areas-&gt;output(); 输出方法的问题在于，AreaCalculator 处理了数据输出逻辑．因此，假如用户希望将数据以 json 或者其他格式输出呢？ 所有逻辑都由 AreaCalculator 类处理，这恰恰违反了单一职责原则(SRP); AreaCalculator 类应该只负责计算图形的总面积，它不应该关心用户是想要json还是HTML格式数据。 因此，要解决这个问题，可以创建一个 SumCalculatorOutputter 类，并使用它来处理所需的显示逻辑，以处理所有图形的总面积该如何显示。 SumCalculatorOutputter 类的工作方式如下： 12345678910111213$shapes = array( new Circle(2), new Square(5), new Square(6));$areas = new AreaCalculator($shapes);$output = new SumCalculatorOutputter($areas);echo $output-&gt;JSON();echo $output-&gt;HAML();echo $output-&gt;HTML();echo $output-&gt;JADE(); 现在，无论你想向用户输出什么格式数据，都由 SumCalculatorOutputter 类处理。 开闭原则 对象和实体应该对扩展开放，但是对修改关闭． 简单的说就是，一个类应该不用修改其自身就能很容易扩展其功能．让我们看一下 AreaCalculator 类，特别是 sum 方法． 1234567891011public function sum() &#123; foreach($this-&gt;shapes as $shape) &#123; if(is_a($shape, 'Square')) &#123; $area[] = pow($shape-&gt;length, 2); &#125; else if(is_a($shape, 'Circle')) &#123; $area[] = pi() * pow($shape-&gt;radius, 2); &#125; &#125; return array_sum($area);&#125; 如果我们想用 sum 方法能计算更多图形的面积，我们就不得不添加更多的 if/else blocks ，然而这违背了开闭原则． 让这个 sum 方法变得更好的方式是将计算每个形状面积的代码逻辑移出 sum 方法，将其放进各个形状类中： 1234567891011class Square &#123; public $length; public function __construct($length) &#123; $this-&gt;length = $length; &#125; public function area() &#123; return pow($this-&gt;length, 2); &#125;&#125; 相同的操作应该被用来处理 Circle 类, 在类中添加一个 area 方法。 现在，计算任何形状面积之和应该像下边这样简单： 1234567public function sum() &#123; foreach($this-&gt;shapes as $shape) &#123; $area[] = $shape-&gt;area(); &#125; return array_sum($area);&#125; 接下来我们可以创建另一个形状类并在计算总和时传递它而不破坏我们的代码。 然而现在又出现了另一个问题，我们怎么能知道传入 AreaCalculator 的对象实际上是一个形状，或者形状对象中有一个 area 方法？ 接口编码是实践 S.O.L.I.D 的一部分，例如下面的例子中我们创建一个接口类，每个形状类都会实现这个接口类： 123456789101112131415interface ShapeInterface &#123; public function area();&#125;class Circle implements ShapeInterface &#123; public $radius; public function __construct($radius) &#123; $this-&gt;radius = $radius; &#125; public function area() &#123; return pi() * pow($this-&gt;radius, 2); &#125;&#125; 在我们的 AreaCalculator 的 sum 方法中，我们可以检查提供的形状类的实例是否是 ShapeInterface 的实现，否则我们就抛出一个异常： 123456789101112public function sum() &#123; foreach($this-&gt;shapes as $shape) &#123; if(is_a($shape, 'ShapeInterface')) &#123; $area[] = $shape-&gt;area(); continue; &#125; throw new AreaCalculatorInvalidShapeException; &#125; return array_sum($area);&#125; 里氏替换原则 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 这句定义的意思是说：每个子类或者衍生类可以毫无问题地替代基类/父类。 依然使用 AreaCalculator 类, 假设我们有一个 VolumeCalculator 类，这个类继承了AreaCalculator 类： 12345678910class VolumeCalculator extends AreaCalculator &#123; public function construct($shapes = array()) &#123; parent::construct($shapes); &#125; public function sum() &#123; // logic to calculate the volumes and then return and array of output return array($summedData); &#125;&#125; SumCalculatorOutputter 类: 123456789101112131415161718192021222324class SumCalculatorOutputter &#123; protected $calculator; public function __construct(AreaCalculator $calculator) &#123; $this-&gt;calculator = $calculator; &#125; public function JSON() &#123; $data = array( 'sum' =&gt; $this-&gt;calculator-&gt;sum(); ); return json_encode($data); &#125; public function HTML() &#123; return implode('', array( '', 'Sum of the areas of provided shapes: ', $this-&gt;calculator-&gt;sum(), '' )); &#125;&#125; 如果我们运行像这样一个例子： 12345$areas = new AreaCalculator($shapes);$volumes = new AreaCalculator($solidShapes);$output = new SumCalculatorOutputter($areas);$output2 = new SumCalculatorOutputter($volumes); 程序不会出问题， 但当我们使用$output2 对象调用 HTML 方法时 ，我们接收到一个 E_NOTICE 错误，提示我们 数组被当做字符串使用的错误。 为了修复这个问题，只需： 1234public function sum() &#123; // logic to calculate the volumes and then return and array of output return $summedData;&#125; 而不是让VolumeCalculator 类的 sum 方法返回数组。 $summedData 是一个浮点数、双精度浮点数或者整型。 接口隔离原则 使用方（client）不应该依赖强制实现不使用的接口，或不应该依赖不使用的方法。 继续使用上面的 shapes 例子，已知拥有一个实心块，如果我们需要计算形状的体积，我们可以在 ShapeInterface 中添加一个方法： 1234interface ShapeInterface &#123; public function area(); public function volume();&#125; 任何形状创建的时候必须实现 volume 方法，但是【平面】是没有体积的，实现这个接口会强制的让【平面】类去实现一个自己用不到的方法。 ISP 原则不允许这么去做，所以我们应该创建另外一个拥有 volume 方法的SolidShapeInterface 接口去代替这种方式，这样类似立方体的实心体就可以实现这个接口了： 1234567891011121314151617interface ShapeInterface &#123; public function area();&#125;interface SolidShapeInterface &#123; public function volume();&#125;class Cuboid implements ShapeInterface, SolidShapeInterface &#123; public function area() &#123; //计算长方体的表面积 &#125; public function volume() &#123; // 计算长方体的体积 &#125;&#125; 这是一个更好的方式，但是要注意提示类型时不要仅仅提示一个 ShapeInterface 或 SolidShapeInterface。 你能创建其它的接口，比如 ManageShapeInterface ,并在平面和立方体的类上实现它，这样你能很容易的看到有一个用于管理形状的api。例： 1234567891011121314151617181920interface ManageShapeInterface &#123; public function calculate();&#125;class Square implements ShapeInterface, ManageShapeInterface &#123; public function area() &#123; /Do stuff here/ &#125; public function calculate() &#123; return $this-&gt;area(); &#125;&#125;class Cuboid implements ShapeInterface, SolidShapeInterface, ManageShapeInterface &#123; public function area() &#123; /Do stuff here/ &#125; public function volume() &#123; /Do stuff here/ &#125; public function calculate() &#123; return $this-&gt;area() + $this-&gt;volume(); &#125;&#125; 现在在 AreaCalculator 类中，我们可以很容易地用 calculate替换对area 方法的调用，并检查对象是否是 ManageShapeInterface 的实例，而不是 ShapeInterface 。 依赖倒置原则最后，但绝不是最不重要的： 实体必须依赖抽象而不是具体的实现．即高等级模块不应该依赖低等级模块，他们都应该依赖抽象． 这也许听起来让人头大，但是它很容易理解．这个原则能够很好的解耦，举个例子似乎是解释这个原则最好的方法： 1234567class PasswordReminder &#123; private $dbConnection; public function __construct(MySQLConnection $dbConnection) &#123; $this-&gt;dbConnection = $dbConnection; &#125;&#125; 首先 MySQLConnection 是低等级模块，然而 PasswordReminder 是高等级模块，但是根据 S.O.L.I.D. 中 D 的解释：_依赖于抽象而不依赖与实现_， 上面的代码段违背了这一原则，因为 PasswordReminder 类被强制依赖于 MySQLConnection 类． 稍后，如果你希望修改数据库驱动，你也不得不修改 PasswordReminder 类，因此就违背了 Open-close principle． 此 PasswordReminder 类不应该关注你的应用使用了什么数据库，为了进一步解决这个问题，我们「面向接口写代码」，由于高等级和低等级模块都应该依赖于抽象，我们可以创建一个接口： 123interface DBConnectionInterface &#123; public function connect();&#125; 这个接口有一个连接数据库的方法，MySQLConnection 类实现该接口，在 PasswordReminder 的构造方法中不要直接将类型约束设置为 MySQLConnection 类，而是设置为接口类，这样无论你的应用使用什么类型的数据库，PasswordReminder 类都能毫无问题地连接数据库，且不违背 开闭原则． 12345678910111213class MySQLConnection implements DBConnectionInterface &#123; public function connect() &#123; return "Database connection"; &#125;&#125;class PasswordReminder &#123; private $dbConnection; public function __construct(DBConnectionInterface $dbConnection) &#123; $this-&gt;dbConnection = $dbConnection; &#125;&#125; 从上面一小段代码，你现在能看出高等级和低等级模块都依赖于抽象了。 总结说实话，S.O.L.I.D 一开始似乎很难掌握，但只要不断地使用和遵守其原则，它将成为你的一部分，使你的代码易被扩展、修改，测试，即使重构也不容易出现问题。 文章转自：https://learnku.com/php/t/28922更多文章：https://learnku.com/php/c/translations]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测IP是否为国内IP]]></title>
    <url>%2Fp%2F003a.html</url>
    <content type="text"><![CDATA[定期获取IP网段这里小编写了shell脚本并且结合crontab定期获取IP网段列表并写入Redis 编写shell脚本获取IP断列表并写入redis中, 保存文件为shell.sh 1234567!#/bin/bashcurl 'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest' | grep ipv4 | grep CN | awk -F\| '&#123; printf("%s/%d\n", $4, 32-log($5)/log(2)) &#125;' &gt; /china_ip.txtcat '/china_ip.txt' |while read p do redis-cli -h 127.0.0.1 -p 6379 hset "china_ip" $p $p &gt;/dev/null done 在crontab 加上以下命令 (每天00:00自动更新脚本) 100 00 * * * /data/shell.sh 使用函数判断指定IP是否存在指定网段中（Laravel框架）12345678910111213141516171819202122232425262728293031323334353637383940/** * Class Sms * @package App\Http\Services\Common * @Author YiYuan-LIn * @Date: 2019/2/28 * 校验IP工具类 */class VerifyIp&#123; /** * @Author YiYuan-LIn * @Date: 2019/8/10 * @enumeration: * @param $ip * @return bool * @description 校验IP是否处于国内的网段 */ public static function CheckWhetherIPIsDomestic($ip) &#123; //校验IP参数是否合法 if (empty($ip)) return false; if(filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) return false; $china_ip = Redis::hkeys('china_ip'); $china_ip = array_filter($china_ip); if (empty($china_ip)) return false; foreach ($china_ip as $key =&gt; $value) &#123; $s = explode('/', $value); $network_start = (double) (sprintf("%u", ip2long($s[0]))); $network_len = pow(2, 32 - $s[1]); $network_end = $network_start + $network_len - 1; if ($ip &gt;= $network_start &amp;&amp; $ip &lt;= $network_end) return true; continue ; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在工作中遇到的一个小需求]]></title>
    <url>%2Fp%2F002a.html</url>
    <content type="text"><![CDATA[夺宝码生成规则 夺宝码为6位，由大写字母和数字组成 生成为规则09，然后AZ；从最末位开始 如第一个夺宝码为000000，之后依次为000001000009,00000A00000Z;当末位数09和AZ都已使用完，则从倒数第二位继续 夺宝码为按照以上顺序依次生成 夺宝码每月1号0点清空重新生成 根据上面的生成规则我们可以清楚的了解到这是一个典型的10进制转36进制的问题，生成代码如下 12345678910111213141516171819202122232425262728&lt;?phpfunction makeTreasureCode($num = 0)&#123; if(empty($num)) return []; $outPut = array(); $outPut[] = base_convert($num, 10, 36); $count = strlen($outPut[0]); if ($count &lt; 6) &#123; $k = 6 - $count; for ($j = $k; $j &gt; 0; $j--) &#123; array_push($outPut, 0); &#125; &#125; $outPut = array_reverse($outPut); $outPut = join('', $outPut); return $outPut;&#125;$num = 5 //生成夺宝码的数量$code = makeTreasureCode($num);echo ''; print_r($code);echo '';]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初步理解JWT]]></title>
    <url>%2Fp%2F001a.html</url>
    <content type="text"><![CDATA[初步理解JWT JWT是一种用于双方之间传递安全信息的简洁的，URL安全的表述性声明规范,JWT作为一个开放的标准(RFC 7519)定义了一种简洁的，自宝行的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库 jWT的主要应用场景身份认证在这种场景下，一旦用户完成了登陆，在接下来的每个请求中包含JWT，可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中传递，所有目前在单点登录（SSO）中比较广泛的使用了该技术。 信息交换在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经过伪造的。 JWT的结构JWT包含了使用.分隔的三部分： Header 头部 Payload 负载 Signature 签名 其结构看起来是这样的Header.Payload.Signature Header在header中通常包含了两部分：token类型和采用的加密算法。{ “alg”: “HS256”, “typ”: “JWT”} 接下来对这部分内容使用 Base64Url 编码组成了JWT结构的第一部分。 PayloadToken的第二部分是负载，它包含了claim， Claim是一些实体（通常指的用户）的状态和额外的元数据，有三种类型的claim：reserved, public 和 private.Reserved claims: 这些claim是JWT预先定义的，在JWT中并不会强制使用它们，而是推荐使用，常用的有 iss（签发者）,exp（过期时间戳）, sub（面向的用户）, aud（接收方）, iat（签发时间）。 Public claims：根据需要定义自己的字段，注意应该避免冲突 Private claims：这些是自定义的字段，可以用来在双方之间交换信息 负载使用的例子：{ “sub”: “1234567890”, “name”: “John Doe”, “admin”: true} 上述的负载需要经过Base64Url编码后作为JWT结构的第二部分。 Signature创建签名需要使用编码后的header和payload以及一个秘钥，使用header中指定签名算法进行签名。例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建： HMACSHA256( base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret) 签名用于验证消息的发送者以及消息是没有经过篡改的。 完整的JWT 完整的JWT格式的输出是以. 分隔的三段Base64编码，与SAML等基于XML的标准相比，JWT在HTTP和HTML环境中更容易传递。 下列的JWT展示了一个完整的JWT格式，它拼接了之前的Header， Payload以及秘钥签名： 如何使用JWT？ 在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie，而使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。 当用户希望访问一个受保护的路由或者资源的时候，通常应该在Authorization头部使用Bearer模式添加JWT，其内容看起来是下面这样：Authorization: Bearer 因为用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。 JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。 下面的序列图展示了该过程： 为什么要使用JWT？ 相比XML格式，JSON更加简洁，编码之后更小，这使得JWT比SAML更加简洁，更加适合在HTML和HTTP环境中传递。 在安全性方面，SWT只能够使用HMAC算法和共享的对称秘钥进行签名，而JWT和SAML token则可以使用X.509认证的公私秘钥对进行签名。与简单的JSON相比，XML和XML数字签名会引入复杂的安全漏洞。 因为JSON可以直接映射为对象，在大多数编程语言中都提供了JSON解析器，而XML则没有这么自然的文档-对象映射关系，这就使得使用JWT比SAML更方便 java json web token工具类]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 的事务四个特性以及事务的四个隔离级别]]></title>
    <url>%2Fp%2F581a.html</url>
    <content type="text"><![CDATA[mysql的事务四个特性以及事务的四个隔离级别======================= 事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据应用该组查询的全部语句，那么久执行该组查询。如果其中任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。 事务的四大特性（ACID） 原子性（atomicity）：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。 一致性（consistency）：数据库总数从一个一致性的状态转换到另一个一致性的状态。 隔离性（isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。 数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。 事务的四种隔离级别Read uncommitted读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。 事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。 分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。 那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。 Read committed读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的… 分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。 那怎么解决可能的不可重复读问题？Repeatable read ！ Repeatable read重复读，就是在开始读取数据（事务开启）时，不再允许修改操作 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。 分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。 什么时候会出现幻读？ 事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。 那怎么解决幻读问题？Serializable！ Serializable 序列化Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。 值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。MySQL的默认隔离级别是Repeatable read 作者：csdnxingyuntian 来源：CSDN 原文：https://blog.csdn.net/csdnxingyuntian/article/details/57081233版权声明：本文为博主原创文章，转载请附上博文链接！a]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>
