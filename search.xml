<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何在PHP中解析Cron表达式]]></title>
    <url>%2Fp%2F001b.html</url>
    <content type="text"><![CDATA[cron表达式简介Cron利用_cron表达式_表示重复计划。Cron表达式由几个字段组成，每个字段代表时间的度量。cron表达式中的字段如下：分钟，小时，每月的某天，月份，一周的某天以及可选的年份。这是一个每分钟运行一次的cron表达式示例，该表达式下方是位置字段。 123456789* * * * * *- - - - - -| | | | | || | | | | + year [optional]| | | | +----- day of week (0 - 7) (Sunday=0 or 7)| | | +---------- month (1 - 12)| | +--------------- day of month (1 - 31)| +-------------------- hour (0 - 23)+------------------------- min (0 - 59) 有几个特殊字符可以修改cron表达式的计划，并且某些修饰符在不同字段中的行为也有所不同。您可以在cron的Wikipedia页面上找到所有可用特殊字符的列表。 安装Cron解析包Github地址： https://github.com/dragonmantank/cron-expression 我们通过composer的方式来安装该包 1composer require dragonmantank/cron-expression 如果你使用的是Laravel框架的话则无需安装此包，这是因为Laravel框架的已经引入该包 使用方法12345678910require_once '/vendor/autoload.php';$cronTab = '* * * * *';//实例化Cron对象$cron = \Cron\CronExpression::factory($cron);//根据Cron表达式计算出下次实行时间 返回一个DateTime对象$cron = $cron-&gt;getNextRunDate();//转换时间为指定格式echo $cron-&gt;format('Y-m-d H:i:s'); 通过上面的代码我们可以轻易的就根据Cron表达式 计算出下次执行时间，是不是很方便呢，当然，这个包提供的方法不仅仅只是单纯计算出下次执行时间，同样我们也可以计算出下X次执行时间 123456$cron = \Cron\CronExpression::factory($cron);foreach($cron-&gt;getMultipleRunDates(5) as $date)&#123; echo $date-&gt;format('Y-m-d H:i:s') . PHP_EOL; &#125; 运行结果： 12345678D:\php7.3\php.exe C:\Users\php\Desktop\local_test\index.php2019-12-30 15:53:002019-12-30 15:54:002019-12-30 15:55:002019-12-30 15:56:002019-12-30 15:57:00Process finished with exit code 0 同样我们可以获取上次的执行时间 以及上X次执行时间： 12345678$cron = \Cron\CronExpression::factory($cron);$cron = $cron-&gt;getPreviousRunDate();echo $cron-&gt;format('Y-m-d H:i:s');$cron = \Cron\CronExpression::factory($cron);foreach($cron-&gt;getMultipleRunDates(5, 'now', true ) as $date)&#123; echo $date-&gt;format('Y-m-d H:i:s') . PHP_EOL; &#125; 我们还可以通过isDue 方法来查看cron表达式是否与特定日期匹配，同时该库也支持一些宏 @yearly，@annually-每年1月1日午夜运行一次-0 0 1 1 * @monthly -每个月的第一天午夜运行一次- 0 0 1 * * @weekly -每周午夜在太阳上运行一次- 0 0 * * 0 @daily -每天半夜运行一次- 0 0 * * * @hourly -第一分钟每小时运行一次- 0 * * * * 我们可以通过这些宏来快速计算出执行时间，例如下面这个例子可以快速计算出每天半夜执行一次的时间： 12$cron = Cron\CronExpression::factory('@daily');echo $cron-&gt;getNextRunDate()-&gt;format('Y-m-d H:i:s'); 参考文献 http://mtdowling.com/blog/2012/06/03/cron-expressions-in-php/ https://github.com/mtdowling/cron-expression]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《开源项目篇》-- Picture_bed 相册展示系统]]></title>
    <url>%2Fp%2F061a.html</url>
    <content type="text"><![CDATA[项目部署首先你得确保你服务器符合以下要求： PHP &gt;= 7.1.3 OpenSSL PHP扩展 PDO PHP扩展，注意需要php_mysql Mbstring PHP扩展 Tokenizer PHP扩展 XML PHP扩展 项目地址： https://github.com/linyiyuan/picture_bed.git 项目演示地址： http://album.linyiyuan.top 第1步：克隆代码 1git clone https://github.com/linyiyuan/picture_bed.git 第2步：安装composer包 1composer install 第3步：配置文件 1、在项目中找到.env.example文件，该文件作为项目的全局配置文件，在部署时需要复制成.env，执行以下命令 1cp -f .env.example ./.env 2、根据.env文件修改各配置项，如果.env文件中没有存在key值则运行命令： 1php artisan key:generate 3、配置stroage bootstrap 可写 1chmod -R 777 stroage bootstrap 第4步：初始化数据库 在根路径上执行以下命令来实现初始化数据库结构。注意执行该命令前请检查项目是否已依赖doctrine/dbal 1php artisan migrate 至此项目部署已经基本以完成，配置相应apache或者nginx 域名指向即可 项目更新 增加了密码相册，允许在相册上设置问题访问，回答问题访问成功后自动保存访问信息，下次访问不需要进行密码认证，有效期为60分钟。 增加了_live2d_模型，可以切换各种角色，目前有10中角色的切换，里面配置了一部分快捷键。 项目展示]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>开源项目</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《工具篇》-- 使用qshell批量下载七牛云储存桶资源]]></title>
    <url>%2Fp%2F021a.html</url>
    <content type="text"><![CDATA[介绍引用官方的一句简介：“qshell是利用七牛文档上公开的API实现的一个方便开发者测试和使用七牛API服务的命令行工具。该工具设计和开发的主要目的就是帮助开发者快速解决问题 ” 下载我们可以通过在七牛云官网上找到下载地址，里面有各个系统版本所对应的下载地址，这里小编选择的windwos amd64 官方下载地址 下载完成后我们将压缩包解压得到一个.exe 后缀的文件 使用首先我们并不能直接打开该文件，直接打开该文件会提示You need to open cmd.exe and run it from there 我们应该先打开windows 的命令行工具，可以使用 Win + R 打开 运行 然后输入 cmd 打开命令行工具 打开命令行工具后我们进入到刚刚解压完qshell的目录 由图显示，小编已经进入该页面，为了方便操作，小编将下载的工具命名为qshell这时候我们就可以使用qshell 提供的相关命令进行操作了 下载资源 鉴权 在进行下载资源之前我们需要鉴权，我们只需要使用命令行配置好相应的key 跟 secret 即可 1qshell account AccessKey SecretKey AccountName 将AccessKey SeretKey AccountName 换成你的七牛账号下的 AccessKey 和 SecretKey以及账号名即可 运行完成后我们可以查看用户信息 1qshell user ls 配置下载信息 我们需要单独配置一个下载配置，我们新建一个文件，命名为download.conf, 然后写入以下内容： 123456789101112&#123; "dest_dir" : "C:\\Users\\sirui-php\\Desktop\\test\\image\\", "bucket" : "test", "prefix" : "photo/pic/", "suffixes" : ".png,.jpg", "cdn_domain" : "", "referer" : "http://www.example.com", "log_file" : "download.log", "log_level" : "info", "log_rotate" : 1, "log_stdout" : false&#125; 参数说明： 参数名 描述 可选参数 dest_dir 本地数据备份路径，为全路径 N bucket 空间名称 N prefix 只同步指定前缀的文件，默认为空 Y suffixes 只同步指定后缀的文件，默认为空 Y cdn_domain 设置下载的CDN域名，默认为空表示从存储源站下载，【该功能默认需要计费，如果希望享受10G的免费流量，请自行设置cdn_domain参数，如不设置，需支付源站流量费用，无法减免！！！】 N referer 如果CDN域名配置了域名白名单防盗链，需要指定一个允许访问的referer地址 N log_level 下载日志输出级别，可选值为debug,info,warn,error,默认info Y log_file 下载日志的输出文件，如果不指定会输出到qshell工作目录下默认的文件中，文件名可以在终端输出看到 Y log_rotate 下载日志文件的切换周期，单位为天，默认为1天即切换到新的下载日志文件 Y log_stdout 下载日志是否同时输出一份到标准终端，默认为false，主要在调试下载功能时可以指定为true Y 其中dest_dir 为你本地保存资源的路径，在Windows系统下面使用的时候，注意dest_dir的设置遵循D:\\jemy\\backup这种方式。也就是路径里面的\要有两个（\\）。 运行命令 配置好下载配置后我们运行以下命令即可下载该存储桶内的所有资源文件 1qshell qdownload test.conf 需要注意的时，如果运行命令报： 表示我需要我们自己手动去创建保存资源的目录，我们新建相应目录即可 参考文献 命令行工具(qshell) qdownload下载文档]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《插件篇》-- 使用Vue + ElementUI 搭建的Cron表达式组件]]></title>
    <url>%2Fp%2F041b.html</url>
    <content type="text"><![CDATA[安装该项目是由 ldy 作者编写，以下文档说明大部分都是从作者项目下转载，非原创 项目地址： https://gitee.com/lindeyi/vue-cron 首先我们将该项目本地克隆下来，然后将 src/components 里面的两个文件 cron.vue, cron 复制到我们的项目中的components中即可。 使用方式在我们需要使用到该插件的页面中去引入该插件, 并注册 12345678import cron from '@/components/cron'export default &#123;name: "App",components: &#123; cron&#125;,.... 然后我们在指定显示组件的地方粘贴下以下代码： 12345678910&lt;el-form-item style="margin-top: -10px; margin-bottom:0px;"&gt; &lt;span style="color: #E6A23C; font-size: 12px;"&gt;corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份&lt;/span&gt; &lt;cron v-if="showCronBox" v-model="cronParams"&gt;&lt;/cron&gt;&lt;/el-form-item&gt; &lt;el-form-item label="cron表达式"&gt; &lt;el-input size="medium" v-model="cronParams" auto-complete="off" placeholder="请填写cron表达式"&gt; &lt;el-button slot="append" v-if="!showCronBox" icon="el-icon-arrow-up" @click="showCronBox= true" title="打开图形配置"&gt;&lt;/el-button&gt; &lt;el-button slot="append" v-else icon="el-icon-arrow-down" @click="showCronBox= false" title="关闭图形配置"&gt;&lt;/el-button&gt; &lt;/el-input&gt;&lt;/el-form-item&gt; 然后我们同样需要在data 数据块中加上以下数据即可： 123456data() &#123; return &#123; cronParams: null, showCronBox: false, &#125;&#125; 页面演示 参考文献 vue-cron 基于Vue的Cron表达式组件 超级好用的Cron表达式组件easy-cron]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《工具篇》-- 使用supervisor来管理Linux的后台进程]]></title>
    <url>%2Fp%2F031a.html</url>
    <content type="text"><![CDATA[Supervisor 介绍Supervisor 是一个进程管理工具，当进程中断的使用Supervisor能自动重新启动它，该工具使用Python语言开发，支持Linux/Unix系统，不支持Windows系统，它可以很方便的监听、启动、停止、重启一个或多个进程。 Supervisor 安装以下安装均在Ubuntu16.04系统下进行 安装 Python 由于Supervisor是由Python语言开发，自然而然我们的系统就需要安装Python语言环境, 一般情况下Ubuntu都自带Python语言环境 1apt-get install python3.7 安装Supervisor 1apt-get install supervisor 安装成功后 运行： 1services supervisor status 查看supervisor 运行状态 Supervisor 配置首先查看Supervisor 的主配置文件，一般文件位于/etc/supervisor/目录下 123456789101112131415161718192021222324252627282930 vim /etc/supervisor/supervisord.conf//文件内容; supervisor config file [unix_http_server]file=/var/run/supervisor.sock ; (the path to the socket file)chmod=0700 ; sockef file mode (default 0700)[supervisord]logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir=/var/log/supervisor ; ('AUTO' child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socket; The [include] section can just contain the "files" setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.[include]files = /etc/supervisor/conf.d/*.conf 从配置文件最后一行可以看出子配置文件位于/etc/supervisor/conf.d/ 目录下，如果没有则新建相应目录即可，我们打开该目录下conf.d目录并新建一个文件 test.conf 1vim test.conf 并写入以下内容： 123456789[program:websocket]command= //需要被监听的进程路径autostart=true //是否随着supervisord的启动而启动autorestart=unexpected //是否自动重启exitcodes=0 //正常退出代码stopsignal=KILL //用来杀死进程的信号user=root //执行命令用户redirect_stderr=true //重定向stderr到stdoutstdout_logfile= //日志路径 紧接着我们重启 Supervisor 服务 1service supervisor restart Supervisord启动成功后，可以通过Supervisorctl客户端控制进程，启动、停止、重启。运行supervisorctl命令 12345root@VM-0-2-ubuntu:/etc/supervisor/conf.d# supervisorctl test RUNNING pid 16350, uptime 1:20:44supervisor&gt; statustest RUNNING pid 16350, uptime 1:20:45supervisor&gt; 然后我们可以看到我们监听的进程test已经 在运行了，我们可以通过以下命令对其进行控制： 123456supervisorctl restart &lt;application name&gt; ;重启指定应用supervisorctl stop &lt;application name&gt; ;停止指定应用supervisorctl start &lt;application name&gt; ;启动指定应用supervisorctl restart all ;重启所有应用supervisorctl stop all ;停止所有应用supervisorctl start all ;启动所有应用 参考文章 linux学习(四) – supervisor守护进程 Supervisor-守护进程工具]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Mysql 分组去重并排序的问题]]></title>
    <url>%2Fp%2F011b.html</url>
    <content type="text"><![CDATA[问题解决假设我们现在有一张用户钱包表 该表包含着四个字段 气质ID字段是递增的 还有用户名(username), 货币数量(currency), 添加时间(addTime), 用户的货币数量随着时间的变化而更新 现在我们需要查询每个用户的最新货币数量，首先我们需要对列表进行排序并对用户去重，所以我们就简单的写了一条sql语句并执行： 1select distinct username, currency, addTime from user_wallet order by addTime desc; 结果显示： 结果显示去重并未生效，在网上查看的资料后，其原因是distinct只能返回他的目标字段，而无法返回其他字段，所以我们使用group by 进行去重 在使用group by之前，由于我本地的MySQL 版本是5.7，而MySQL5.7 默认的 MySQL 配置中 sql_mode 配置了 only_full_group，需要 GROUP BY 中包含所有 在 SELECT 中出现的字段, 所以我们需要在MySQL 的配置中去掉这个配置: 在 配置文件（my.cnf）中 修改 sql_mode 的配置为： 12$ vim /usr/local/etc/my.cnfsql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 然后重启MYSQL服务即可： 结果显示，去重已经生效，但是排序未生效，这是因为我们是先去重拿到结果后再进行的排序，所以排序也是针对于去重后的结果进行排序，所以我们对这条Sql语句进行修改： 1select username, currency, addTime FROM (select username, currency, addTime from user_wallet order by addTime DESC) alias GROUP BY username; 结果发现排序还是未能生效， 小编在查阅了相关资料后，发现在mysql 5.7 中 ，这种语法并没有效果，正确的写法是： 1select username, currency, addTime FROM (select username, currency, addTime from user_wallet order by addTime DESC limit 0, 10000) alias GROUP BY username; 通过 explain 查看执行计划，可以看到没有 limit 的时候，少了一个 DERIVED 操作。DERIVED用于派生表的SELECT(FROM子句的子查询)，所以没有它就相当于子句里的排序并没有被执行。至此问题解决 注意事项 采用子句查询时，别名（alias）不可少，会报语法错误 如果有分页，分页条件要写在子句里面 需要去重mysql的严格模式 参考文章 Mysql5.7分组排序 解决MySQL：1055 - Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Working</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你必须了解的PHP7垃圾回收机制]]></title>
    <url>%2Fp%2F009a.html</url>
    <content type="text"><![CDATA[1. 垃圾的产生我们PHP的变量都是基于引用计数这个机制来进行一个变量回收，当变量赋值、传递时并不会直接硬拷贝，而是增加value的引用数，unset、return等释放变量时再减掉引用数，减掉后如果发现refcount变为0则直接释放value，这是变量的基本gc过程，但是还存在着一种情况是这种机制无法解决的，由这种情况产生的垃圾无法被回收导致内存始终得不到释放。这种情况就是循环引用，我们先来看一个官方例子： 123456$a = [1];$a[] = &amp;$a;unset($a); 这是一个数据循环引用的例子， 首先我们申明一个变量$a 并赋值一个数组[1] ，紧接着我们给$a数组元素赋值，而这个值又是引用自己, 即变量 a 变成了自己引用自己. 此时zend_reference的refcount(引用次数) 为 2, 然后我们现在unset($a) 从图中可以看到 unset($a) 之后 zend_reference 结构体的引用计数减 1，但是仍然大于 0，此时是无法通过正常的gc机制回收的，但是$a已经已经没有任何外部引用了，所以这种变量就是垃圾，垃圾回收器要处理的就是这种情况，对此不处理的话，就可能会造成内存泄露。这里就需要垃圾收集器将这部分收集到缓冲区，之后进行回收处理。这里明确两个准则： 如果一个变量value的refcount减少到0， 那么此value可以被释放掉，不属于垃圾 如果一个变量value的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾 针对第一个情况GC不会处理，只有第二种情况GC才会将变量收集起来。另外变量是否加入垃圾检查buffer并不是根据zval的类型判断的，而是与前面介绍的是否用到引用计数一样通过zval.u1.type_flag记录的，只有包含IS_TYPE_COLLECTABLE的变量才会被GC收集。 目前垃圾只会出现在array、object两种类型中，数组的情况上面已经介绍了，object的情况则是成员属性引用对象本身导致的，其它类型不会出现这种变量中的成员引用变量自身的情况，所以垃圾回收只会处理这两种类型的变量。 1#define IS_TYPE_COLLECTABLE 12345678910| type | collectable |+----------------+-------------+|simple types | ||string | ||interned string | ||array | Y ||immutable array | ||object | Y ||resource | ||reference | | 2. 回收过程如果当变量的refcount减少后大于0，PHP并不会立即进行对这个变量进行垃圾鉴定，而是放入一个缓冲buffer中，等这个buffer满了以后(10000个值)再统一进行处理，加入buffer的是变量zend_value的zend_refcounted_h: zend_refcounted_h 结构如下： 123456789101112typedef struct _zend_refcounted_h &#123; uint32_t refcount; // 记录 zend_value 的引用数 union &#123; struct &#123; zend_uchar type, // zend_value的类型, 与zval.u1.type一致 zend_uchar flags, uint16_t gc_info // GC信息，记录在 gc 池中的位置和颜色，垃圾回收的过程会用到 &#125; v; uint32_t type_info; &#125; u;&#125; zend_refcounted_h; 一个变量只能加入一次buffer，为了防止重复加入，变量加入后会把zend_refcounted_h.gc_info置为GC_PURPLE，即标为紫色，下次refcount减少时如果发现已经加入过了则不再重复插入。垃圾缓存区是一个双向链表，等到缓存区满了以后则启动垃圾检查过程：遍历缓存区，再对当前变量的所有成员进行遍历，然后把成员的refcount减1(如果成员还包含子成员则也进行递归遍历，其实就是深度优先的遍历)，最后再检查当前变量的引用，如果减为了0则为垃圾。这个算法的原理很简单，垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，结果如果发现变量本身refcount变为了0则就表明其引用全部来自自身成员。具体的过程如下： (1) 从buffer链表的roots开始遍历，把当前value标为灰色(zend_refcounted_h.gc_info置为GC_GREY)，然后对当前value的成员进行深度优先遍历，把成员value的refcount减1，并且也标为灰色； (2) 重复遍历buffer链表，检查当前value引用是否为0，为0则表示确实是垃圾，把它标为白色(GC_WHITE)，如果不为0则排除了引用全部来自自身成员的可能，表示还有外部的引用，并不是垃圾，这时候因为步骤(1)对成员进行了refcount减1操作，需要再还原回去，对所有成员进行深度遍历，把成员refcount加1，同时标为黑色； (3) 再次遍历buffer链表，将非GC_WHITE的节点从roots链表中删除，最终roots链表中全部为真正的垃圾，最后将这些垃圾清除。 以上就是我对PHP垃圾回收机制的一些理解总结，大部分内容都是来《PHP内核解析》，关于垃圾收集的内部实现 如果有兴趣想了解的话可以去阅读《PHP内核解析》，因为里面基本都是基于C语言的一些算法，本文章只是大概总结PHP垃圾回收机制的一些知识点，底层的一些算法实现不给予总结。 参考资料 PHP内核解析之变量的内部实现 PHP内核解析之垃圾回收 深入理解 PHP7 中全新的 zval 容器和引用计数机制 PHP内核解析之变量的内部实现 浅析 PHP7 的垃圾回收机制 PHP垃圾回收机制]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解PHP7变量的内部实现]]></title>
    <url>%2Fp%2F008a.html</url>
    <content type="text"><![CDATA[1. Zval在任何一个语言中都存在着变量，变量是一个语言实现的基础, 而变量有两个组成部分：变量名、变量值 而 Zval 就是PHP语言中变量基础结构, 变量有两个组成部分：变量名、变量值，PHP中可以将其对应为：zval、zend_value，这两个概念一定要区分开，PHP中变量的内存是通过引用计数进行管理的，而且PHP7中引用计数是在zend_value而不是zval上，变量之间的传递、赋值通常也是针对zend_value，下面我先简单了解下Zval的基础结构 1.1 Zval基础结构123456789101112131415161718192021222324252627282930313233343536373839404142434445//zend_types.htypedef struct _zval_struct zval;typedef union _zend_value &#123; zend_long lval; //int整形 double dval; //浮点型 zend_refcounted *counted; zend_string *str; //string字符串 zend_array *arr; //array数组 zend_object *obj; //object对象 zend_resource *res; //resource资源类型 zend_reference *ref; //引用类型，通过&amp;$var_name定义的 zend_ast_ref *ast; //下面几个都是内核使用的value zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct &#123; uint32_t w1; uint32_t w2; &#125; ww;&#125; zend_value;struct _zval_struct &#123; zend_value value; //变量实际的value union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( //这个是为了兼容大小字节序，小字节序就是下面的顺序，大字节序则下面4个顺序翻转 zend_uchar type, //变量类型 zend_uchar type_flags, //类型掩码，不同的类型会有不同的几种属性，内存管理会用到 zend_uchar const_flags, zend_uchar reserved) //call info，zend执行流程会用到 &#125; v; uint32_t type_info; //上面4个值的组合值，可以直接根据type_info取到4个对应位置的值 &#125; u1; union &#123; uint32_t var_flags; uint32_t next; //哈希表中解决哈希冲突时用到 uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ &#125; u2; //一些辅助值&#125;; 对于该结构的详细描述来自于《PHP内核解析》，zval结构比较简单，内嵌一个union类型的zend_value保存具体变量类型的值或指针，zval中还有两个union：u1、u2 我们重点理解 zend_value 从zend_value可以看出，除long、double类型直接存储值外，其它类型都为指针，指向各自的结构。 1.2 引用类型在本文章我们重点讲解 引用 这个特殊类型，而其他类型如：字符串 数组等均不作详细讲解，引用《PHP内核解析》的一段话 “引用是PHP中比较特殊的一种类型，它实际是指向另外一个PHP变量，对它的修改会直接改动实际指向的zval，可以简单的理解为C中的指针，在PHP中通过&amp;操作符产生一个引用变量，也就是说不管以前的类型是什么，&amp;首先会创建一个zend_reference结构，其内嵌了一个zval，这个zval的value指向原来zval的value(如果是布尔、整形、浮点则直接复制原来的值)，然后将原zval的类型修改为IS_REFERENCE，原zval的value指向新创建的zend_reference结构” 1234struct _zend_reference &#123; zend_refcounted_h gc; zval val;&#125;; 其中 zend_reference 内存拥有一个自己的value 还有一个zend_fefcounted_h(引用计数器), 而我们的垃圾回收机制也是基于此，现在让我们来看一个官方例子： 12$a = "time:" . time(); //$a -&gt; zend_string_1(refcount=1)$b = &amp;$a; //$a,$b -&gt; zend_reference_1(refcount=2) -&gt; zend_string_1(refcount=1) 首先我们声明了一个变量$a并赋值 “time() . time()”, 此时内存分配给了$a一个zval_struct容器 并且容器value指向 zend_string 此时该zend_string 的refcount(引用次数) 为1，然后我们继续声明了$b 变量 并引用赋值$a, 此时$b 也拥有了属于她的zval_struct 容器，由于是引用传递，所以&amp;首先会创建一个zend_reference结构 然后该结构的zend_reference.value指向$a 所指向的zend_string , 紧接着$a 的 zval_struct.value 的数据类型会被修改为 zend_refrence并将 $a zval_struct.value 指向刚刚申请并初始化后的 zend_reference 最后为新变量申请 zval_struct 结构，将他的 value 指向刚刚创建的 zend_reference， 此时：$a 和 $b 都拥有一个 zval_struct 结构体，并且他们的 zval_struct.value 都指向了同一个 zend_reference 结构，所以该结构的引用计数器的值为 2。 题外话：zend_reference 又指向了一个整形或浮点型的 value，如果指向的 value 类型是 zend_string，那么该 value 引用计数器的值为 1。而 xdebug 出来的 refcount 显示的是 zend_reference 的计数器值（即 2）。最终的结果如图： 注意：引用只能通过&amp;产生，无法通过赋值传递，比如： 1234$a = &quot;time:&quot; . time(); //$a -&gt; zend_string_1(refcount=1)$b = &amp;$a; //$a,$b -&gt; zend_reference_1(refcount=2) -&gt; zend_string_1(refcount=1)$c = $b; //$a,$b -&gt; zend_reference_1(refcount=2) -&gt; zend_string_1(refcount=2) //$c -&gt; --- $b = &amp;$a这时候$a、$b的类型是引用，但是$c = $b并不会直接将$b赋值给$c，而是把$b实际指向的zval赋值给$c，如果想要$c也是一个引用则需要这么操作： 123$a = &quot;time:&quot; . time(); //$a -&gt; zend_string_1(refcount=1)$b = &amp;$a; //$a,$b -&gt; zend_reference_1(refcount=2) -&gt; zend_string_1(refcount=1)$c = &amp;$b;/*或$c = &amp;$a*/ //$a,$b,$c -&gt; zend_reference_1(refcount=3) -&gt; zend_string_1(refcount=1) 这个也表示PHP中的 引用只可能有一层 ，不会出现一个引用指向另外一个引用的情况 ，也就是没有C语言中指针的指针的概念。 2.内存管理在理解了上面内容后我们对引用计数大概有了一个认识，接下来我们来详细理解PHP7变量的销毁和分配，这些都是基于 引用计数+写时复制， PHP变量的管理正是基于这两点实现的。 2.1 引用计数引用计数是指在value中增加一个字段refcount记录指向当前value的数量，变量复制、函数传参时并不直接硬拷贝一份value数据;而是将refcount++，变量销毁时将refcount--，等到refcount减为0时表示已经没有变量引用这个value，将它销毁即可, 下面我们来看一个官方例子： 硬拷贝这种方式是可行的，而且内存管理也很简单，但是，硬拷贝带来的一个问题是效率低，比如我们定义了一个变量然后赋值给另外一个变量，可能后面都只是只读操作，假如硬拷贝的话就会有多余的一份数据.12345$a = "time:" . time(); //$a -&gt; zend_string_1(refcount=1)$b = $a; //$a,$b -&gt; zend_string_1(refcount=2)$c = $b; //$a,$b,$c -&gt; zend_string_1(refcount=3)unset($b); //$b = IS_UNDEF $a,$c -&gt; zend_string_1(refcount=2) 首先我们先定义一个变量$a并赋值, 这里为什么要赋值“time:” .time() 待会会详细讲解，这设计到引用计数的几种特殊类型，这时候我们的$a有了一个属于它的zval_struct 容器，而她的value 则指向一个zend_value, 而变量值则处于这个zend_value中，接着声明了了$b，并赋值$a,这时候$b同样生成一个属于它的zval_struct容器，而它的value 也同意指向zend_value,此时该zend_value的refcount(引用计数)为2, $c同理， 现在我们来看下引用计数所处的结构，引用计数的信息位于给具体value结构的gc中： 123456789101112typedef struct _zend_refcounted_h &#123; uint32_t refcount; /* reference counter 32-bit */ union &#123; struct &#123; ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, /* used for strings &amp; objects */ uint16_t gc_info) /* keeps GC root number (or 0) and color */ &#125; v; uint32_t type_info; &#125; u;&#125; zend_refcounted_h; 现在我们来讲讲关于几种特殊情况下不会使用到引用计数，我们从上面的结构可以看出并不是所有的数据类型都会用到引用计数，以下几种类型都不会使用引用计数： IS_LONG IS_DOUBLE IS_TRUE IS_FALSE IS_NULL 首先NULL、布尔型都属于没有值的数据类型（其中布尔型通过 IS_FALSE 和 IS_TRUE 两个常量来标记），自然也就没有引用计数， 而 IS_LONG, IS_DOUBLE 这两种类型是zval 在 value 字段中能保存下的值，就不会在对他们进行引用计数，而是在拷贝的时候直接赋值 即我们在 PHP 中的整形与浮点型。所以有下面几种情况: 123456789$str_integer = 123; -&gt;zend_string_1(refcount=0,val="123")$str_float = 123.123; -&gt;zend_string_1(refcount=0,val="123.123")$str_true = true; -&gt;zend_string_1(refcount=0,val="true")$str_false = false; -&gt;zend_string_1(refcount=0,val="false")$str_null = null; -&gt;zend_string_1(refcount=0,val="null") 除了以上五种五种特殊类型，我们再来看一个官方例子： 123$a = "hi~";$b = $a; 不同于上面最开始的例子，我们对$a 赋值一个简单的字符串 然后$b赋值$a, 此时我们肯定以为$a,$b指向的zend_value refcount = 2, 但是官方给出的答案这个是错的，gdb调试发现上面例子zend_string的引用计数为0。这是为什么呢？实际上： $a,$b -&gt; zend_string_1(refcount=0,val=&quot;hi~&quot;)当然这是官方的说法，我在本地使用PHP7.3的环境运行，使用xdebug_debug_zval 调试，发现结果并不是跟官方一致： 123456789101112echo phpversion() . PHP_EOL;$a = "hi~";$b = $a;xdebug_debug_zval('a');//结果：7.3.0-2+ubuntu18.04.1+deb.sury.org+1a: (refcount=1, is_ref=0)='hi~' 然后不信邪的继续使用PHP7.2环境运行，结果： 127.2.19-0ubuntu0.18.04.2a: (refcount=0, is_ref=0)='123' 发现PHP7.2与PHP7.3的结果完全不一致，我怀疑是PHP7.3更新时更新了一些东西导致的，目前在官方文档并未找到任何相关信息，我们还是具体以官方例子为准，在得出结果后作者会对该问题进行补充 我们继续接着上面的例子，事实上并不是所有的PHP变量都会用到引用计数，标量：true/false/double/long/null是硬拷贝自然不需要这种机制，但是除了这几个还有两个特殊的类型也不会用到：interned string(内部字符串，就是上面提到的字符串flag：IS_STR_INTERNED)、immutable array，它们的type是IS_STRING、IS_ARRAY，与普通string、array类型相同： interned string： 内部字符串，这是种什么类型？我们在PHP中写的所有字符都可以认为是这种类型，比如function name、class name、variable name、静态字符串等等，我们这样定义:$a = &quot;hi~&quot;;后面的字符串内容是唯一不变的，这些字符串等同于C语言中定义在静态变量区的字符串：char *a = &quot;hi~&quot;;，这些字符串的生命周期为request期间，request完成后会统一销毁释放，自然也就无需在运行期间通过引用计数管理内存。 interned string 内部字符串（函数名、类名、变量名、静态字符串）： 12 $str = '233'; // 静态字符串复制代码 普通字符串： 1$str = '233' . time(); immutable array： 不可变数组是 opcache 扩展优化出的一种数组类型，简单的说，所有多次编译结果恒定不变的数组，都会被优化为不可变数组 可变数组 1$array = [1, 2, time()]; 不可变数组： 1$str = [1,2]; 注意 : 不可变数组和我们上面讲到的内部字符串一样，都是不使用引用计数的，但是不同点是，内部字符串的计数值恒为 0，而不可变数组会使用一个伪计数值 2。 2.2 写时复制上一小节介绍了引用计数，多个变量可能指向同一个value，然后通过refcount统计引用数，这时候如果其中一个变量试图更改value的内容则会重新拷贝一份value修改，同时断开旧的指向，写时复制的机制在计算机系统中有非常广的应用，它只有在必要的时候(写)才会发生硬拷贝，可以很好的提高效率，下面从示例看下： 123456$a = array(1,2);$b = &amp;$a;$c = $a;//发生分离$b[] = 3; 不是所有类型都可以copy的，比如对象、资源，事实上只有string、array两种支持，与引用计数相同，也是通过zval.u1.type_flag标识value是否可复制的： 1#define IS_TYPE_COPYABLE (1&lt;&lt;4) 12345678910| type | copyable |+----------------+------------+|simple types | ||string | Y ||interned string | ||array | Y ||immutable array | ||object | ||resource | ||reference | | copyable 的意思是当value发生duplication时是否需要或者能够copy，这个具体有两种情形下会发生： a.从 literal变量区 复制到 局部变量区 ，比如：$a = [];实际会有两个数组，而$a = &quot;hi~&quot;;//interned string则只有一个string b.局部变量区分离时(写时复制)：如改变变量内容时引用计数大于1则需要分离，$a = [];$b = $a; $b[] = 1;这里会分离，类型是array所以可以复制，如果是对象：$a = new user;$b = $a;$a-&gt;name = &quot;dd&quot;;这种情况是不会复制object的，$a、$b指向的对象还是同一个 具体literal、局部变量区变量的初始化、赋值后面编译、执行两篇文章会具体分析，这里知道变量有个copyable的属性就行了。 2.3 变量回收PHP变量的回收主要有两种：主动销毁、自动销毁。主动销毁指的就是 unset ，而自动销毁就是PHP的自动管理机制，在return时减掉局部变量的refcount，即使没有显式的return，PHP也会自动给加上这个操作，另外一个就是写时复制时会断开原来value的指向，这时候也会检查断开后旧value的refcount。 2.4 垃圾回收PHP变量的回收是根据refcount实现的，当unset、return时会将变量的引用计数减掉，如果refcount减到0则直接释放value，这是变量的简单gc过程，PHP变量一般情况下都可以被回收，但是实际上也会出现gc无法回收导致内存泄漏的bug，我们这里举几个例子进行讲解，具体得一个垃圾回收机制 我将会在下篇文章具体讲解 先看下一个例子： 12345$a = [1];$a[] = &amp;$a;unset($a); unset($a)之前引用关系： unset($a)之后： 可以看到，unset($a)之后由于数组中有子元素指向$a，所以refcount &gt; 0，无法通过简单的gc机制回收，这种变量就是垃圾，垃圾回收器要处理的就是这种情况，目前垃圾只会出现在array、object两种类型中，所以只会针对这两种情况作特殊处理：当销毁一个变量时，如果发现减掉refcount后仍然大于0，且类型是IS_ARRAY、IS_OBJECT则将此value放入gc可能垃圾双向链表中，等这个链表达到一定数量(10000)后启动检查程序将所有变量检查一遍，如果确定是垃圾则销毁释放。 标识变量是否需要回收也是通过u1.type_flag区分的： 1#define IS_TYPE_COLLECTABLE 12345678910| type | collectable |+----------------+-------------+|simple types | ||string | ||interned string | ||array | Y ||immutable array | ||object | Y ||resource | ||reference | | 以上就是对PHP7变量的内部实现的总结，其中大部分内容都来自《PHP内核解析》，本人只不过对其进行了总结整合，因为网上大部分文章其实都是停留在PHP5.x的环境，容易误导，所以我在学习过程中将自己所查阅的资料总结起来，方便大家对其的理解。 参考资料 PHP内核解析之变量的内部实现 深入理解PHP7之zval confusion about php-7 refcount PHP引用变量机制(PHP如何处理变量) 跟厂长学PHP7内核（八）：深入理解字符串的实现 引用计数基本知识 深入理解 PHP7 中全新的 zval 容器和引用计数机制]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHP源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PHP生成器Yield的使用（下）]]></title>
    <url>%2Fp%2F007a.html</url>
    <content type="text"><![CDATA[深入解析在上一节中我们使用了memory_get_usage 来检测使用Yield时的内存使用情况，可以发现使用Yield优化的代码其内存使用量非常少，这也引发了一个问题，为什么使用Yield时其内存使用少，我们可以使用以下代码对其进行测试 首先我们先简单实现一个简单的函数 1234567function createRange($number)&#123; $data = []; for($i=0;$i&lt;$number;$i++)&#123; $data[] = time(); &#125; return $data;&#125; 这是一个非常常见的PHP函数，我们在处理一些数组的时候经常会使用。这里的代码也非常简单： 我们创建一个函数。 函数内包含一个for循环，我们循环的把当前时间放到$data里面 for循环执行完毕，把$data返回出去。 下面没完，我们继续。我们再写一个函数，把这个函数的返回值循环打印出来： 12345$result = createRange(10); // 这里调用上面我们创建的函数foreach($result as $value)&#123; sleep(1);//这里停顿1秒，我们后续有用 echo $value.&apos;&lt;br /&gt;&apos;;&#125; 运行结果： 从图中可以发现，程序运行了10秒， 其遍历的数组全部一致，从结果上看并没有问题，现在我们使用Yield生成器对 createRange() 函数进行修改： 12345function createRange($number)&#123; for($i=0;$i&lt;$number;$i++)&#123; yield time(); &#125;&#125; 运行结果： 从结果上我们可以发现，两次输出值不一样，使用了Yield的结果上每次输出的时间戳都多了1秒 这里的间隔一秒其实就是sleep(1)造成的后果。但是为什么第一次没有间隔？那是因为： 未使用生成器时：createRange函数内的for循环结果被很快放到$data中，并且立即返回。所以，foreach循环的是一个固定的数组。 使用生成器时：createRange的值不是一次性快速生成，而是依赖于foreach循环。foreach循环一次，for执行一次。 我们来还原一下代码执行过程。 首先调用createRange函数，传入参数10，但是for值执行了一次然后停止了，并且告诉foreach第一次循环可以用的值。 foreach开始对$result循环，进来首先sleep(1)，然后开始使用for给的一个值执行输出。 foreach准备第二次循环，开始第二次循环之前，它向for循环又请求了一次。 for循环于是又执行了一次，将生成的时间戳告诉foreach. foreach拿到第二个值，并且输出。由于foreach中sleep(1)，所以，for循环延迟了1秒生成当前时间 所以，整个代码执行中，始终只有一个记录值参与循环，内存中也只有一条信息。 无论开始传入的$number有多大，由于并不会立即生成所有结果集，所以内存始终是一条循环的值。 概念理解到这里，你应该已经大概理解什么是生成器了。下面我们来说下生成器原理。 首先明确一个概念：生成器yield关键字不是返回值，他的专业术语叫产出值，只是生成一个值 那么代码中foreach循环的是什么？其实是PHP在使用生成器的时候，会返回一个Generator类的对象。foreach可以对该对象进行迭代，每一次迭代，PHP会通过Generator实例计算出下一次需要迭代的值。这样foreach就知道下一次需要迭代的值了。 而且，在运行中for循环执行后，会立即停止。等待foreach下次循环时候再次和for索要下次的值的时候，for循环才会再执行一次，然后立即再次停止。直到不满足条件不执行结束。 应用场景从上一章节中我们可以了解到，使用Yield 可以大大减少PHP使用的内存大小，PHP开发的时候很多时候都要读取大文件，比如CSV文件，txt文件，或者一些日志文件，如果文件大小没那么大的情况下我们可以直接一次性将所有内容读取到内存中计算，但是如果文件过大，比如5个G的文件，这时候我们使用直接一次性把所有的内容读取到内存中计算不太现实，所以我们可以使用Yield来帮助我们处理这些大型文件 简单看个例子：读取txt文件： 我们创建一个text文本文档，并在其中输入几行文字，示范读取。 12345678910111213141516171819&lt;?phpheader(&quot;content-type:text/html;charset=utf-8&quot;);function readTxt()&#123; # code... $handle = fopen(&quot;./test.txt&quot;, &apos;rb&apos;); while (feof($handle)===false) &#123; # code... yield fgets($handle); &#125; fclose($handle);&#125;foreach (readTxt() as $key =&gt; $value) &#123; # code... echo $value.&apos;&lt;br /&gt;&apos;;&#125; 通过上图的输出结果我们可以看出代码完全正常。 但是，背后的代码执行规则却一点儿也不一样。使用生成器读取文件，第一次读取了第一行，第二次读取了第二行，以此类推，每次被加载到内存中的文字只有一行，大大的减小了内存的使用。 这样，即使读取上G的文本也不用担心，完全可以像读取很小文件一样编写代码。 引用文章 PHP中被忽略的性能优化利器：生成器 PHP YIELD使读取大文件]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于PHP生成器Yield的使用（上）]]></title>
    <url>%2Fp%2F006a.html</url>
    <content type="text"><![CDATA[前言在认识这个强大的神器之前我们先了解几个常见PHP内置函数内存相关常见常数， memory_get_usage(): 返回当前分配给PHP脚本的内存量，单位是字节（byte） memory_get_peak_usage(): 返回内存使用峰值 getrusage():返回CUP使用情况 我们在日常开发中可以使用这些内置函数来调试PHP代码性能。但需要注意的是这几个函数只能在linux系统中使用 在认识以上三个函数之后我们来做一个简单的小测, 我们迭代数组一个1-1000的数组 123456789$start_memory = memory_get_usage();$numberArr = range(1, 1000);foreach($numberArr as $key) &#123; //echo $key;&#125;$end_memory = memory_get_usage();echo '运行该迭代数组所耗内存：' . ($end_memory - $start_memory) . 'bytes'; 运行结果： 运行该迭代数组所耗内存：528440 bytes折算成kb单位就是大概是528kb, 这样一看并没觉得什么，这时候我们继续增大数组范围，我们将范围扩大成1-1000000 运行结果： 运行该迭代数组所耗内存：4198480 bytes大概是4m左右，这时候还是可以遍历得出来，我们继续增大1-10000000 运行结果： Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 536870920 bytes) in /data/default/index.php on line 11 发现报错了，系统提示内存溢出了 134217728 bytes 大概是134MB, 我们再查看一下PHP配置文件 果不其然，配置文件限制的内存最大值是128 我们执行该程序的内存使用明显超出限制，这时候我们只能修改此配置文件使其限制内存更大些，但是如果遇到超级大的数据量，或者让你去处理一个几个G的Excel文件时，你会发现修改这个配置文件并不能从根本解决问题，配置内存还需要考虑到服务器的内存使用情况等等， 认识Yield这时候我们就可以使用 Yield 这个强大的神器，下面我们使用Yield 优化我们上面的代码 12345678910111213141516$start_memory = memory_get_usage();function yield_range($start, $end) &#123; while( $start &lt;= $end )&#123; $start++; yield $start; &#125;&#125;$numberArr = yield_range(1, 10000000);foreach($numberArr as $key) &#123; // echo $key;&#125;$end_memory = memory_get_usage();echo '运行该迭代数组所耗内存：' . ($end_memory - $start_memory) . ' bytes'; 运行一下，让你们感受下 运行该迭代数组所耗内存：320 bytes我擦，使用内存竟然连1kb都没有，那么，我们来分析一波儿这个神奇的yield_range函数。这个yield关键字到底返回的是什么？我们简单看一下： 123456789function yield_range( $start, $end )&#123; while( $start &lt;= $end )&#123; $start++; yield $start; &#125;&#125;$rs = yield_range( 1, 100 );var_dump( $rs ); /* object(Generator)#1 (0) { } */GeneratorYield 返回的是一个叫做Generator（中文名就是生成器）的object对象，该对象是由generators(生成器)返回，不能通过new实例化，而这个生成器是实现了Iterator接口，该接口提供了一下几个方法： abstract public current ( void ) : mixed abstract public key ( void ) : scalar abstract public next ( void ) : void abstract public rewind ( void ) : void abstract public valid ( void ) : bool 而Generator又包含一下几个方法： Generator::current — 返回当前产生的值 Generator::key — 返回当前产生的键 Generator::next — 生成器继续执行 Generator::rewind — 重置迭代器 Generator::send — 向生成器中传入一个值 Generator::throw — 向生成器中抛入一个异常 Generator::valid — 检查迭代器是否被关闭 Generator::__wakeup — 序列化回调 所以，既然实现了Iterator接口（也正是因为如此，这个东西可以使用foreach进行迭代，明白了吧？），所以可以有如下代码： 123456789101112131415&lt;?phpfunction yield_range( $start, $end )&#123; while( $start &lt;= $end )&#123; yield $start; $start++; &#125;&#125;$generator = yield_range( 1, 10 );// valid() current() next() 都是Iterator接口中的方法while( $generator-&gt;valid() )&#123; echo $generator-&gt;current().PHP_EOL; $generator-&gt;next();&#125; 1 2 3 4 5 6 7 8 9 10 重点来了：这个yield_range函数似乎能够记住它上一次运行到哪儿了，上一次运行的结果是什么，然后紧接着在下一次运行的时候继续从上次终止的地方继续开始。这不是普通的PHP函数可以做得到的！ 我们知道，操作系统在调度进程的时候，会触发一个叫做“进程上下文切换”的概念。比如CPU从进程A调度给进程B了，那么当再次从进程B调度给进程A的时候，当初进程A运行到哪儿了、临时的数据结果是什么都是需要被还原的，不然，一切都要从头，那就要出大问题了。而，这个yield关键字，似乎在用户态（非系统内核级）就可以实现这个概念. 接下来我们来认识一个Generator对象的一个方法 –send 12345678910&lt;?phpfunction yield_range( $start, $end )&#123; while( $start &lt;= $end )&#123; $ret = yield $start; $start++; echo "yield receive : ".$ret.PHP_EOL; &#125;&#125;$generator = yield_range( 1, 10 );$generator-&gt;send( $generator-&gt;current() * 10 ); //执行结果 yield receive : 10send方法可以修改yield的返回值 , 我们继续修改代码 123456789101112&lt;?phpfunction yield_range( $start, $end )&#123; while( $start &lt;= $end )&#123; $ret = yield $start; $start++; echo "yield receive : ".$ret . PHP_EOL; &#125;&#125;$generator = yield_range( 1, 10 );foreach( $generator as $item )&#123; $generator-&gt;send( $generator-&gt;current() * 10 );&#125; 结果发现 这是PHP存在的一个Bug, 我们需要注意的是我们在foreach 去使用生成器的send方法，以下是bug的链接，有兴趣的可以去看下 https://bugs.php.net/bug.php?id=76104 https://stackoverflow.com/questions/37817315/how-does-generatorsend-work 引用文章 PHP中的yield（上) 生成器类 Iterator（迭代器）接口 PHP内置函数memory_get_usage()获取内存使用和getrusage()返回CUP使用情况]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次关于Vue的打包调优过程]]></title>
    <url>%2Fp%2F041a.html</url>
    <content type="text"><![CDATA[分析问题在进行优化的前提下，首先要做得是对整个框架进行分析，看看具体哪个模块以及那个插件打包体积过大，针对性的进行优化，在这里我们通过 webpack-bundle-analyzer 进行分析 步骤1： 1npm install --save-dev webpack-bundle-analyzer //安装插件 步骤2: 123456//在`build/webpack.prod.config.js`中的`module.exports = webpackConfig`这句话的上面增加if (config.build.bundleAnalyzerReport) &#123; const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125; 步骤3: 1npm run build --report 结果： 通过结果我们不难发现，体积过大的文件有一下几个： element-ui vue echarts xlsx tinymce vCharts 优化问题优化主要目的有： 加快资源加载速度，减少用户等待的时间和首页白屏时间，提高用户体验。 加快打包速度，不要将时间浪费在等待打包上。 更换CDN：解决第一个问题，很多人都会想到资源文件放在 CDN 上就好了，没错，这次我们就是通过 CDN 来解决加载问题。 在 index.html 中引入 vue, element-ui tinymce echarts。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt; &lt;!-- 同时也要引入对应版本的 css --&gt; &lt;link href="https://cdn.bootcss.com/element-ui/2.3.2/theme-chalk/index.css" rel="external nofollow" rel="stylesheet"&gt; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/v-charts/lib/style.min.css"&gt; &lt;title&gt;Vue-admin-template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="./static/tinymce4.7.5/tinymce.min.js"&gt;&lt;/script&gt; &lt;!-- 先引入 Vue --&gt; &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.min.js"&gt;&lt;/script&gt; &lt;!-- 引入组件库 --&gt; &lt;script src="https://cdn.bootcss.com/element-ui/2.3.2/index.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/element-ui/2.3.2/locale/zh-CN.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/echarts/3.7.0/echarts.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/v-charts/lib/index.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/xlsx/0.15.1/cpexcel.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/xlsx/0.15.1/xlsx.core.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/v-charts/lib/style.min.css"&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 因为依赖是从外部引入的，所以需要告知 webpack 在打包时，依赖的来源。 修改 webpack.base.conf.js 在最后一行加上一下代码： 1234567 externals: &#123; vue: 'Vue', 'element-ui':'ELEMENT', "echarts": "echarts", "vCharts": "v-charts", 'xlsx': "xlsx"&#125; 删除所有引入/导入Vcharts , echarts, tinymce 的地方 再次 npm run build –report 发现其打包文件体积比之前足足少了2MB，在实际开发过程中，可能会使用到其他的插件，我们可以根据插件来更换其CDN从而减少其打包体积大小，这样页面在加载的时候也会更快 服务器端开启 gzip使用 gzip 可以进一步压缩文件，使得服务器传递给浏览器的文件是经由压缩之后的，待浏览器收到之后再解压缩。要使用这一方式，需要服务器端的支持，这里以 Nginx 为例。 在 nginx.conf 中，添加如下配置： 1234567gzip on;gzip_min_length 1k;gzip_buffers 4 16k;#gzip_http_version 1.0;gzip_comp_level 2;gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png application/javascript;gzip_vary off; 之后刷新页面（ 注意禁用缓存 ），观察 js、css 等资源文件的请求中是否包含 Content-Encoding: gzip，如果存在，则表明 gzip 已成功。 注意，在 gzip_types 中规定了哪些请求类型会使用 gzip 进行压缩。对于没有使用 gzip 的资源文件，可将其 Content-type 类型加入 gzip_types 之中。 参考 实例 PK ( Vue服务端渲染 VS Vue 浏览器端渲染 ) - segmentfault 使用vue-cli生成的vendor.js文件太大，有办法减少体积吗？ - segmentfault Webpack 打包优化之体积篇 babel-plugin-lodash Nginx开启Gzip压缩大幅提高页面加载速度 - 博客园 Nginx启用Gzip压缩js无效的原因 - 博客园 Wabpack系列：在webpack+vue开发环境中使用echarts导致编译文件过大怎么办？ - 博客园 Webpack 打包优化之速度篇 如何写一手漂亮的 Vue]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式——建造者模式]]></title>
    <url>%2Fp%2F005a.html</url>
    <content type="text"><![CDATA[前言 建造者模式也称生成器模式，核心思想是将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。 建造者模式一般认为有四个角色： 产品角色，产品角色定义自身的组成属性 抽象建造者，抽象建造者定义了产品的创建过程以及如何返回一个产品 具体建造者，具体建造者实现了抽象建造者创建产品过程的方法，给产品的具体属性进行赋值定义 指挥者，指挥者负责与调用客户端交互，决定创建什么样的产品 为什么使用： 对象的生产需要复杂的初始化，比如给一大堆类成员属性赋初值，设置一下其他的系统环境变量。使用建造者模式可以将这些初始化工作封装起来。 对象的生成时可根据初始化的顺序或数据不同，而生成不同角色。 例如：汽车，他的发动机引擎有好多品牌，轮胎也有各种材质，内饰更是千奇百怪；鸟，他的头、翅膀以及脚有各种颜色和形状，在创建这种复杂对象的时候，我们建议使用建造者模式。 应用在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物 实例以下将用一个大家比较熟悉的游戏《英雄联盟》 作为一个简单的例子，现在我们想创建一个角色，我们通过使用建造者模式去设计如果创建不同的属性的角色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223/** * Class Role * @Author YiYuan-LIn * @Date: 2019/8/15 * 定义一个角色类 */class Role&#123; /** * 姓名 * @var string */ public $name; /** * 攻击力 * @var integer */ public $power; /** * 攻速 * @var float */ public $attack_speed; /** * 暴击 * @var integer */ public $crit; /** * @Author YiYuan-LIn * @Date: 2019/8/15 * @description 显示信息 */ public function display() &#123; echo '姓名：' . $this-&gt;name . '&lt;br&gt;'; echo '攻击力：' . $this-&gt;power . '&lt;br&gt;'; echo '攻击速度：' . $this-&gt;attack_speed . '&lt;br&gt;'; echo '暴击几率：' . $this-&gt;crit . '&lt;br&gt;'; &#125;&#125;/** * Class RoleBuilder * @Author YiYuan-LIn * @Date: 2019/8/15 * 定义一个射手抽象类 */abstract class RoleBuilder&#123; public $_role; /** * ShooterBuilder constructor. * 初始化一个射手 */ public function __construct() &#123; $this-&gt;_role = new Role(); &#125; /** * @Author YiYuan-LIn * @Date: 2019/8/15 * @enumeration: * @return mixed * @description 设置名字 */ abstract public function setName(); /** * @Author YiYuan-LIn * @Date: 2019/8/15 * @enumeration: * @return mixed * @description 设置力量值 */ abstract public function setPower(); /** * @Author YiYuan-LIn * @Date: 2019/8/15 * @enumeration: * @return mixed * @description 设置攻击速度 */ abstract public function setAttackSpeed(); /** * @Author YiYuan-LIn * @Date: 2019/8/15 * @enumeration: * @return mixed * @description 设置暴击几率 */ abstract public function setCrit(); /** * @Author YiYuan-LIn * @Date: 2019/8/15 * @enumeration: * @return mixed * @description 建立角色 */ abstract public function builder();&#125;/** * Class Ez * @Author YiYuan-LIn * @Date: 2019/8/15 * 定义个伊泽瑞尔射手 */class Ez extends RoleBuilder&#123; public function setName() &#123; // TODO: Implement setName() method. $this-&gt;_role-&gt;name = '伊泽瑞尔'; &#125; public function setPower() &#123; // TODO: Implement setPower() method. $this-&gt;_role-&gt;power = 100; &#125; public function setAttackSpeed() &#123; // TODO: Implement setAttackSpeed() method. $this-&gt;_role-&gt;attack_speed = 0.75; &#125; public function setCrit() &#123; // TODO: Implement setCrit() method. $this-&gt;_role-&gt;crit = 0; &#125; public function builder() &#123; // TODO: Implement builder() method. return $this-&gt;_role; &#125;&#125;/** * Class AoBaMa * @Author YiYuan-LIn * @Date: 2019/8/15 * 定义一个奥巴马的角色 */class AoBaMa extends RoleBuilder&#123; public function setName() &#123; // TODO: Implement setName() method. $this-&gt;_role-&gt;name = '奥巴马'; &#125; public function setPower() &#123; // TODO: Implement setPower() method. $this-&gt;_role-&gt;power = 200; &#125; public function setAttackSpeed() &#123; // TODO: Implement setAttackSpeed() method. $this-&gt;_role-&gt;attack_speed = 2.50; &#125; public function setCrit() &#123; // TODO: Implement setCrit() method. $this-&gt;_role-&gt;crit = 100; &#125; public function builder() &#123; // TODO: Implement builder() method. return $this-&gt;_role; &#125;&#125;class RoleDirector&#123; private $_role; public function __construct(RoleBuilder $role) &#123; $this-&gt;_role = $role; &#125; public function build() &#123; $this-&gt;_role-&gt;setName(); $this-&gt;_role-&gt;setPower(); $this-&gt;_role-&gt;setAttackSpeed(); $this-&gt;_role-&gt;setCrit(); return $this-&gt;_role-&gt;builder(); &#125;&#125;$anBaMaRole = new RoleDirector(new AoBaMa());$anBaMaRole = $anBaMaRole-&gt;build();$anBaMaRole-&gt;display();//var_dump($anBaMaRole);echo '&lt;br&gt;';$ezRole = new RoleDirector(new Ez());$ezRole = $ezRole-&gt;build();$ezRole-&gt;display();//var_dump($ezRole); 总结使用建造者模式时，我们把创建一个role实例的过程分为了两步. 一步是先交给对应角色的建造者，如Ez建造者。这样的好处就把角色的属性设置封装了起来，我们不用在new一个Role时，因为要得到一个Ez角色的实例，而在外面写了一堆$ez-&gt;power=70。 另一步是交给了一个建造指挥者，调了一个built方法，通过先设置power，再设置Crit的顺序，初始化这个角色。当然在这个例子中，初始化的顺序，是无所谓的。但是如果对于一个建造汉堡，或是地图，初始化的顺序不同，可能就会得到不同的结果。 也许，你会说，我直接设置也很方便呀。是的，对于某些情况是这样的。但是如果你考虑，我现在想增加一个寒冰角色呢？如果我现在想让建造有初始化有三种不同的顺序呢？ 如果你使用了建造者模式，这两个问题就简单了，增加一个寒冰角色，那就增加一个寒冰建造者类。初始化三种不同的顺序，那么就在指挥建造者中增加两种建造方法。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转载) S.O.L.I.D PHP 面向对象设计的五个基准原则]]></title>
    <url>%2Fp%2F004a.html</url>
    <content type="text"><![CDATA[S.O.L.I.D 意思是：扩展出来的首字母缩略词看起来可能很复杂，实际上它们很容易理解。 S - 单一功能原则 O - 开闭原则 L - 里氏替换原则 I - 接口隔离原则 D - 依赖反转原则 接下来让我们看看每个原则，来了解为什么 S.O.L.I.D 可以帮助我们成为更好的开发人员。 单一职责原则缩写是 S.R.P ，该原则内容是: 一个类有且只能有一个因素使其改变，意思是一个类只应该有单一职责． 例如，假设我们有一些图形，并且想要计算这些图形的总面积．是的，这很简单对不对？ 123456789101112131415class Circle &#123; public $radius; public function __construct($radius) &#123; $this-&gt;radius = $radius; &#125;&#125;class Square &#123; public $length; public function __construct($length) &#123; $this-&gt;length = $length; &#125;&#125; 首先，我们创建图形类，该类的构造方法初始化必要的参数．接下来，创建AreaCalculator 类，然后编写计算指定图形总面积的逻辑代码． 123456789101112131415161718192021class AreaCalculator &#123; protected $shapes; public function __construct($shapes = array()) &#123; $this-&gt;shapes = $shapes; &#125; public function sum() &#123; // logic to sum the areas &#125; public function output() &#123; return implode('', array( "", "Sum of the areas of provided shapes: ", $this-&gt;sum(), "" )); &#125;&#125; AreaCalculator 使用方法，我们只需简单的实例化这个类，并且传递一个图形数组，在页面底部展示输出内容． 123456789$shapes = array( new Circle(2), new Square(5), new Square(6));$areas = new AreaCalculator($shapes);echo $areas-&gt;output(); 输出方法的问题在于，AreaCalculator 处理了数据输出逻辑．因此，假如用户希望将数据以 json 或者其他格式输出呢？ 所有逻辑都由 AreaCalculator 类处理，这恰恰违反了单一职责原则(SRP); AreaCalculator 类应该只负责计算图形的总面积，它不应该关心用户是想要json还是HTML格式数据。 因此，要解决这个问题，可以创建一个 SumCalculatorOutputter 类，并使用它来处理所需的显示逻辑，以处理所有图形的总面积该如何显示。 SumCalculatorOutputter 类的工作方式如下： 12345678910111213$shapes = array( new Circle(2), new Square(5), new Square(6));$areas = new AreaCalculator($shapes);$output = new SumCalculatorOutputter($areas);echo $output-&gt;JSON();echo $output-&gt;HAML();echo $output-&gt;HTML();echo $output-&gt;JADE(); 现在，无论你想向用户输出什么格式数据，都由 SumCalculatorOutputter 类处理。 开闭原则 对象和实体应该对扩展开放，但是对修改关闭． 简单的说就是，一个类应该不用修改其自身就能很容易扩展其功能．让我们看一下 AreaCalculator 类，特别是 sum 方法． 1234567891011public function sum() &#123; foreach($this-&gt;shapes as $shape) &#123; if(is_a($shape, 'Square')) &#123; $area[] = pow($shape-&gt;length, 2); &#125; else if(is_a($shape, 'Circle')) &#123; $area[] = pi() * pow($shape-&gt;radius, 2); &#125; &#125; return array_sum($area);&#125; 如果我们想用 sum 方法能计算更多图形的面积，我们就不得不添加更多的 if/else blocks ，然而这违背了开闭原则． 让这个 sum 方法变得更好的方式是将计算每个形状面积的代码逻辑移出 sum 方法，将其放进各个形状类中： 1234567891011class Square &#123; public $length; public function __construct($length) &#123; $this-&gt;length = $length; &#125; public function area() &#123; return pow($this-&gt;length, 2); &#125;&#125; 相同的操作应该被用来处理 Circle 类, 在类中添加一个 area 方法。 现在，计算任何形状面积之和应该像下边这样简单： 1234567public function sum() &#123; foreach($this-&gt;shapes as $shape) &#123; $area[] = $shape-&gt;area(); &#125; return array_sum($area);&#125; 接下来我们可以创建另一个形状类并在计算总和时传递它而不破坏我们的代码。 然而现在又出现了另一个问题，我们怎么能知道传入 AreaCalculator 的对象实际上是一个形状，或者形状对象中有一个 area 方法？ 接口编码是实践 S.O.L.I.D 的一部分，例如下面的例子中我们创建一个接口类，每个形状类都会实现这个接口类： 123456789101112131415interface ShapeInterface &#123; public function area();&#125;class Circle implements ShapeInterface &#123; public $radius; public function __construct($radius) &#123; $this-&gt;radius = $radius; &#125; public function area() &#123; return pi() * pow($this-&gt;radius, 2); &#125;&#125; 在我们的 AreaCalculator 的 sum 方法中，我们可以检查提供的形状类的实例是否是 ShapeInterface 的实现，否则我们就抛出一个异常： 123456789101112public function sum() &#123; foreach($this-&gt;shapes as $shape) &#123; if(is_a($shape, 'ShapeInterface')) &#123; $area[] = $shape-&gt;area(); continue; &#125; throw new AreaCalculatorInvalidShapeException; &#125; return array_sum($area);&#125; 里氏替换原则 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 这句定义的意思是说：每个子类或者衍生类可以毫无问题地替代基类/父类。 依然使用 AreaCalculator 类, 假设我们有一个 VolumeCalculator 类，这个类继承了AreaCalculator 类： 12345678910class VolumeCalculator extends AreaCalculator &#123; public function construct($shapes = array()) &#123; parent::construct($shapes); &#125; public function sum() &#123; // logic to calculate the volumes and then return and array of output return array($summedData); &#125;&#125; SumCalculatorOutputter 类: 123456789101112131415161718192021222324class SumCalculatorOutputter &#123; protected $calculator; public function __construct(AreaCalculator $calculator) &#123; $this-&gt;calculator = $calculator; &#125; public function JSON() &#123; $data = array( 'sum' =&gt; $this-&gt;calculator-&gt;sum(); ); return json_encode($data); &#125; public function HTML() &#123; return implode('', array( '', 'Sum of the areas of provided shapes: ', $this-&gt;calculator-&gt;sum(), '' )); &#125;&#125; 如果我们运行像这样一个例子： 12345$areas = new AreaCalculator($shapes);$volumes = new AreaCalculator($solidShapes);$output = new SumCalculatorOutputter($areas);$output2 = new SumCalculatorOutputter($volumes); 程序不会出问题， 但当我们使用$output2 对象调用 HTML 方法时 ，我们接收到一个 E_NOTICE 错误，提示我们 数组被当做字符串使用的错误。 为了修复这个问题，只需： 1234public function sum() &#123; // logic to calculate the volumes and then return and array of output return $summedData;&#125; 而不是让VolumeCalculator 类的 sum 方法返回数组。 $summedData 是一个浮点数、双精度浮点数或者整型。 接口隔离原则 使用方（client）不应该依赖强制实现不使用的接口，或不应该依赖不使用的方法。 继续使用上面的 shapes 例子，已知拥有一个实心块，如果我们需要计算形状的体积，我们可以在 ShapeInterface 中添加一个方法： 1234interface ShapeInterface &#123; public function area(); public function volume();&#125; 任何形状创建的时候必须实现 volume 方法，但是【平面】是没有体积的，实现这个接口会强制的让【平面】类去实现一个自己用不到的方法。 ISP 原则不允许这么去做，所以我们应该创建另外一个拥有 volume 方法的SolidShapeInterface 接口去代替这种方式，这样类似立方体的实心体就可以实现这个接口了： 1234567891011121314151617interface ShapeInterface &#123; public function area();&#125;interface SolidShapeInterface &#123; public function volume();&#125;class Cuboid implements ShapeInterface, SolidShapeInterface &#123; public function area() &#123; //计算长方体的表面积 &#125; public function volume() &#123; // 计算长方体的体积 &#125;&#125; 这是一个更好的方式，但是要注意提示类型时不要仅仅提示一个 ShapeInterface 或 SolidShapeInterface。 你能创建其它的接口，比如 ManageShapeInterface ,并在平面和立方体的类上实现它，这样你能很容易的看到有一个用于管理形状的api。例： 1234567891011121314151617181920interface ManageShapeInterface &#123; public function calculate();&#125;class Square implements ShapeInterface, ManageShapeInterface &#123; public function area() &#123; /Do stuff here/ &#125; public function calculate() &#123; return $this-&gt;area(); &#125;&#125;class Cuboid implements ShapeInterface, SolidShapeInterface, ManageShapeInterface &#123; public function area() &#123; /Do stuff here/ &#125; public function volume() &#123; /Do stuff here/ &#125; public function calculate() &#123; return $this-&gt;area() + $this-&gt;volume(); &#125;&#125; 现在在 AreaCalculator 类中，我们可以很容易地用 calculate替换对area 方法的调用，并检查对象是否是 ManageShapeInterface 的实例，而不是 ShapeInterface 。 依赖倒置原则最后，但绝不是最不重要的： 实体必须依赖抽象而不是具体的实现．即高等级模块不应该依赖低等级模块，他们都应该依赖抽象． 这也许听起来让人头大，但是它很容易理解．这个原则能够很好的解耦，举个例子似乎是解释这个原则最好的方法： 1234567class PasswordReminder &#123; private $dbConnection; public function __construct(MySQLConnection $dbConnection) &#123; $this-&gt;dbConnection = $dbConnection; &#125;&#125; 首先 MySQLConnection 是低等级模块，然而 PasswordReminder 是高等级模块，但是根据 S.O.L.I.D. 中 D 的解释：_依赖于抽象而不依赖与实现_， 上面的代码段违背了这一原则，因为 PasswordReminder 类被强制依赖于 MySQLConnection 类． 稍后，如果你希望修改数据库驱动，你也不得不修改 PasswordReminder 类，因此就违背了 Open-close principle． 此 PasswordReminder 类不应该关注你的应用使用了什么数据库，为了进一步解决这个问题，我们「面向接口写代码」，由于高等级和低等级模块都应该依赖于抽象，我们可以创建一个接口： 123interface DBConnectionInterface &#123; public function connect();&#125; 这个接口有一个连接数据库的方法，MySQLConnection 类实现该接口，在 PasswordReminder 的构造方法中不要直接将类型约束设置为 MySQLConnection 类，而是设置为接口类，这样无论你的应用使用什么类型的数据库，PasswordReminder 类都能毫无问题地连接数据库，且不违背 开闭原则． 12345678910111213class MySQLConnection implements DBConnectionInterface &#123; public function connect() &#123; return "Database connection"; &#125;&#125;class PasswordReminder &#123; private $dbConnection; public function __construct(DBConnectionInterface $dbConnection) &#123; $this-&gt;dbConnection = $dbConnection; &#125;&#125; 从上面一小段代码，你现在能看出高等级和低等级模块都依赖于抽象了。 总结说实话，S.O.L.I.D 一开始似乎很难掌握，但只要不断地使用和遵守其原则，它将成为你的一部分，使你的代码易被扩展、修改，测试，即使重构也不容易出现问题。 文章转自：https://learnku.com/php/t/28922更多文章：https://learnku.com/php/c/translations]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测IP是否为国内IP]]></title>
    <url>%2Fp%2F003a.html</url>
    <content type="text"><![CDATA[定期获取IP网段这里小编写了shell脚本并且结合crontab定期获取IP网段列表并写入Redis 编写shell脚本获取IP断列表并写入redis中, 保存文件为shell.sh 1234567!#/bin/bashcurl 'http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest' | grep ipv4 | grep CN | awk -F\| '&#123; printf("%s/%d\n", $4, 32-log($5)/log(2)) &#125;' &gt; /china_ip.txtcat '/china_ip.txt' |while read p do redis-cli -h 127.0.0.1 -p 6379 hset "china_ip" $p $p &gt;/dev/null done 在crontab 加上以下命令 (每天00:00自动更新脚本) 100 00 * * * /data/shell.sh 使用函数判断指定IP是否存在指定网段中（Laravel框架）12345678910111213141516171819202122232425262728293031323334353637383940/** * Class Sms * @package App\Http\Services\Common * @Author YiYuan-LIn * @Date: 2019/2/28 * 校验IP工具类 */class VerifyIp&#123; /** * @Author YiYuan-LIn * @Date: 2019/8/10 * @enumeration: * @param $ip * @return bool * @description 校验IP是否处于国内的网段 */ public static function CheckWhetherIPIsDomestic($ip) &#123; //校验IP参数是否合法 if (empty($ip)) return false; if(filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) return false; $ip = (double) (sprintf("%u", ip2long($ip))); $china_ip = Redis::hkeys('china_ip'); $china_ip = array_filter($china_ip); if (empty($china_ip)) return false; foreach ($china_ip as $key =&gt; $value) &#123; $s = explode('/', $value); $network_start = (double) (sprintf("%u", ip2long($s[0]))); $network_len = pow(2, 32 - $s[1]); $network_end = $network_start + $network_len - 1; if ($ip &gt;= $network_start &amp;&amp; $ip &lt;= $network_end) return true; continue ; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在工作中遇到的一个小需求]]></title>
    <url>%2Fp%2F002a.html</url>
    <content type="text"><![CDATA[夺宝码生成规则 夺宝码为6位，由大写字母和数字组成 生成为规则09，然后AZ；从最末位开始 如第一个夺宝码为000000，之后依次为000001000009,00000A00000Z;当末位数09和AZ都已使用完，则从倒数第二位继续 夺宝码为按照以上顺序依次生成 夺宝码每月1号0点清空重新生成 根据上面的生成规则我们可以清楚的了解到这是一个典型的10进制转36进制的问题，生成代码如下 1234567891011121314151617181920212223242526function makeTreasureCode($num = 0)&#123; if(empty($num)) return []; $outPut = array(); $outPut[] = base_convert($num, 10, 36); $count = strlen($outPut[0]); if ($count &lt; 6) &#123; $k = 6 - $count; for ($j = $k; $j &gt; 0; $j--) &#123; array_push($outPut, 0); &#125; &#125; $outPut = array_reverse($outPut); $outPut = join('', $outPut); return $outPut;&#125;$num = 5 //生成夺宝码的数量$code = makeTreasureCode($num);echo ''; print_r($code);echo '';]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初步理解JWT]]></title>
    <url>%2Fp%2F001a.html</url>
    <content type="text"><![CDATA[初步理解JWT JWT是一种用于双方之间传递安全信息的简洁的，URL安全的表述性声明规范,JWT作为一个开放的标准(RFC 7519)定义了一种简洁的，自宝行的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库 jWT的主要应用场景身份认证在这种场景下，一旦用户完成了登陆，在接下来的每个请求中包含JWT，可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中传递，所有目前在单点登录（SSO）中比较广泛的使用了该技术。 信息交换在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经过伪造的。 JWT的结构JWT包含了使用.分隔的三部分： Header 头部 Payload 负载 Signature 签名 其结构看起来是这样的Header.Payload.Signature Header在header中通常包含了两部分：token类型和采用的加密算法。{ “alg”: “HS256”, “typ”: “JWT”} 接下来对这部分内容使用 Base64Url 编码组成了JWT结构的第一部分。 PayloadToken的第二部分是负载，它包含了claim， Claim是一些实体（通常指的用户）的状态和额外的元数据，有三种类型的claim：reserved, public 和 private.Reserved claims: 这些claim是JWT预先定义的，在JWT中并不会强制使用它们，而是推荐使用，常用的有 iss（签发者）,exp（过期时间戳）, sub（面向的用户）, aud（接收方）, iat（签发时间）。 Public claims：根据需要定义自己的字段，注意应该避免冲突 Private claims：这些是自定义的字段，可以用来在双方之间交换信息 负载使用的例子：{ “sub”: “1234567890”, “name”: “John Doe”, “admin”: true} 上述的负载需要经过Base64Url编码后作为JWT结构的第二部分。 Signature创建签名需要使用编码后的header和payload以及一个秘钥，使用header中指定签名算法进行签名。例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建： HMACSHA256( base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret) 签名用于验证消息的发送者以及消息是没有经过篡改的。 完整的JWT 完整的JWT格式的输出是以. 分隔的三段Base64编码，与SAML等基于XML的标准相比，JWT在HTTP和HTML环境中更容易传递。 下列的JWT展示了一个完整的JWT格式，它拼接了之前的Header， Payload以及秘钥签名： 如何使用JWT？ 在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie，而使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。 当用户希望访问一个受保护的路由或者资源的时候，通常应该在Authorization头部使用Bearer模式添加JWT，其内容看起来是下面这样：Authorization: Bearer 因为用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。 JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。 下面的序列图展示了该过程： 为什么要使用JWT？ 相比XML格式，JSON更加简洁，编码之后更小，这使得JWT比SAML更加简洁，更加适合在HTML和HTTP环境中传递。 在安全性方面，SWT只能够使用HMAC算法和共享的对称秘钥进行签名，而JWT和SAML token则可以使用X.509认证的公私秘钥对进行签名。与简单的JSON相比，XML和XML数字签名会引入复杂的安全漏洞。 因为JSON可以直接映射为对象，在大多数编程语言中都提供了JSON解析器，而XML则没有这么自然的文档-对象映射关系，这就使得使用JWT比SAML更方便 java json web token工具类]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 的事务四个特性以及事务的四个隔离级别]]></title>
    <url>%2Fp%2F011a.html</url>
    <content type="text"><![CDATA[mysql的事务四个特性以及事务的四个隔离级别======================= 事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据应用该组查询的全部语句，那么久执行该组查询。如果其中任何一条语句因为崩溃或其他原因无法执行，那么所有语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。 事务的四大特性（ACID） 原子性（atomicity）：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。 一致性（consistency）：数据库总数从一个一致性的状态转换到另一个一致性的状态。 隔离性（isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。 数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。 事务的四种隔离级别Read uncommitted读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。 事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。 分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。 那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。 Read committed读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的… 分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。 那怎么解决可能的不可重复读问题？Repeatable read ！ Repeatable read重复读，就是在开始读取数据（事务开启）时，不再允许修改操作 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。 分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。 什么时候会出现幻读？ 事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。 那怎么解决幻读问题？Serializable！ Serializable 序列化Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。 值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。MySQL的默认隔离级别是Repeatable read 作者：csdnxingyuntian 来源：CSDN 原文：https://blog.csdn.net/csdnxingyuntian/article/details/57081233版权声明：本文为博主原创文章，转载请附上博文链接！a]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>
